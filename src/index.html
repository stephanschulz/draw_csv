<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Visualization</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f5f5f5;
            padding: 20px;
        }
        canvas {
            border: 1px solid #ccc;
            background-color: white;
        }
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
        .header {
            background-color: #333;
            color: white;
            padding: 15px;
            text-align: center;
        }
        .controls {
            display: flex;
            padding: 10px;
            background-color: #eee;
            justify-content: center;
            gap: 20px;
        }
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #stats {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f8f8;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Graph Visualization</h1>
    </div>
    
    <div class="controls">
        <button id="btn-load-graph">Load Graph</button>
        <button id="btn-toggle-labels">Toggle Labels</button>
        <button id="btn-toggle-edges">Toggle Edges</button>
    </div>
    
    <div id="canvas-container">
        <canvas id="canvas" width="800" height="600"></canvas>
    </div>
    
    <div id="tooltip"></div>
    
    <div id="stats">
        <h3>Graph Statistics</h3>
        <div id="graph-stats"></div>
    </div>
    
    <script src="graph_parser.js"></script>
    <script src="csv_to_graph.js"></script>
    <script>
        // Get elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const graphStatsDiv = document.getElementById('graph-stats');
        const loadGraphBtn = document.getElementById('btn-load-graph');
        const toggleLabelsBtn = document.getElementById('btn-toggle-labels');
        const toggleEdgesBtn = document.getElementById('btn-toggle-edges');
        
        // Visualization options
        let showLabels = true;
        let showEdges = true;
        
        // Graph data
        let graph = null;
        
        // Min/max for scaling
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        // Initialize
        function init() {
            // First try to convert the original CSV to graph format
            convertOriginalCSV();
            
            loadGraphBtn.addEventListener('click', async () => {
                graph = await loadGraph();
                if (graph) {
                    calculateBounds();
                    displayGraphStats();
                    drawGraph();
                }
            });
            
            toggleLabelsBtn.addEventListener('click', () => {
                showLabels = !showLabels;
                if (graph) drawGraph();
            });
            
            toggleEdgesBtn.addEventListener('click', () => {
                showEdges = !showEdges;
                if (graph) drawGraph();
            });
            
            // Mouse events for hover info
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
        }
        
        // Convert original CSV to graph format
        async function convertOriginalCSV() {
            try {
                // Check if the original CSV exists
                const originalFiles = ['simple_points.csv', 'csv_test.csv'];
                let csvFile = null;
                
                for (const file of originalFiles) {
                    try {
                        const response = await fetch(file, { method: 'HEAD' });
                        if (response.ok) {
                            csvFile = file;
                            break;
                        }
                    } catch (e) {
                        console.log(`File ${file} not found, trying next option`);
                    }
                }
                
                if (!csvFile) {
                    console.warn('No source CSV file found, skipping conversion');
                    return;
                }
                
                console.log(`Found CSV file: ${csvFile}, starting conversion...`);
                const result = await convertCSVToGraphFiles(csvFile);
                
                // Save the files using Fetch API
                await saveFile('nodes.csv', result.nodesCSV);
                await saveFile('edges.csv', result.edgesCSV);
                
                console.log(`Conversion complete: Created ${result.stats.nodeCount} nodes and ${result.stats.edgeCount} edges`);
                
                // Auto-load the graph after conversion
                graph = await loadGraph();
                if (graph) {
                    calculateBounds();
                    displayGraphStats();
                    drawGraph();
                }
            } catch (error) {
                console.error('Error converting CSV:', error);
            }
        }
        
        // Save a file to the server (this requires server-side support)
        async function saveFile(filename, content) {
            const blob = new Blob([content], { type: 'text/csv' });
            
            // For demonstration purposes, we'll just download the file
            // In a real application, you would use a server-side API to save the file
            console.log(`Generated ${filename} with ${content.split('\n').length - 1} rows`);
            
            // Display file info in stats
            const statsElement = document.createElement('div');
            statsElement.innerHTML = `<p>Generated ${filename} with ${content.split('\n').length - 1} rows</p>`;
            graphStatsDiv.appendChild(statsElement);
            
            // Uncomment this to download files during development
            // downloadFile(content, filename);
        }
        
        // Download a file (helper function)
        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        // Calculate min/max bounds for scaling
        function calculateBounds() {
            minX = Infinity;
            maxX = -Infinity;
            minY = Infinity;
            maxY = -Infinity;
            
            for (const node of graph.nodes.values()) {
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
                minY = Math.min(minY, node.y);
                maxY = Math.max(maxY, node.y);
            }
        }
        
        // Display graph statistics
        function displayGraphStats() {
            let statsHTML = `
                <p>Nodes: ${graph.nodes.size}</p>
                <p>Edges: ${graph.edges.length}</p>
            `;
            
            // Find node with highest degree
            let maxDegree = 0;
            let maxDegreeNode = null;
            
            for (const nodeId of graph.nodes.keys()) {
                const degree = graph.getDegree(nodeId);
                if (degree > maxDegree) {
                    maxDegree = degree;
                    maxDegreeNode = nodeId;
                }
            }
            
            if (maxDegreeNode !== null) {
                statsHTML += `<p>Node with highest connections: ${maxDegreeNode} (${maxDegree} connections)</p>`;
            }
            
            graphStatsDiv.innerHTML = statsHTML;
        }
        
        // Draw the graph
        function drawGraph() {
            if (!graph) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const padding = 40;
            const scaleX = (canvas.width - padding * 2) / (maxX - minX || 1);
            const scaleY = (canvas.height - padding * 2) / (maxY - minY || 1);
            
            // Use the smaller scale to maintain aspect ratio
            const scale = Math.min(scaleX, scaleY);
            
            // Center the drawing on canvas
            const offsetX = padding + (canvas.width - padding * 2 - (maxX - minX) * scale) / 2;
            const offsetY = padding + (canvas.height - padding * 2 - (maxY - minY) * scale) / 2;
            
            // Draw edges first (if enabled)
            if (showEdges) {
                ctx.lineWidth = 2;
                
                for (const edge of graph.edges) {
                    const sourceNode = graph.nodes.get(edge.source);
                    const targetNode = graph.nodes.get(edge.target);
                    
                    const sourceX = offsetX + (sourceNode.x - minX) * scale;
                    const sourceY = offsetY + (sourceNode.y - minY) * scale;
                    const targetX = offsetX + (targetNode.x - minX) * scale;
                    const targetY = offsetY + (targetNode.y - minY) * scale;
                    
                    // Draw edge
                    ctx.strokeStyle = '#888';
                    ctx.beginPath();
                    ctx.moveTo(sourceX, sourceY);
                    ctx.lineTo(targetX, targetY);
                    ctx.stroke();
                }
            }
            
            // Draw nodes
            for (const [nodeId, node] of graph.nodes.entries()) {
                const x = offsetX + (node.x - minX) * scale;
                const y = offsetY + (node.y - minY) * scale;
                
                // Calculate node radius based on degree (min 5, max 15)
                const degree = graph.getDegree(nodeId);
                const radius = Math.max(5, Math.min(15, 5 + degree * 2));
                
                // Draw node circle
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw outline
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw label if enabled
                if (showLabels) {
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(nodeId, x, y);
                }
            }
        }
        
        // Handle mouse movement for hover information
        function handleMouseMove(event) {
            if (!graph) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Calculate the scale factors
            const padding = 40;
            const scaleX = (canvas.width - padding * 2) / (maxX - minX || 1);
            const scaleY = (canvas.height - padding * 2) / (maxY - minY || 1);
            const scale = Math.min(scaleX, scaleY);
            
            // Calculate the offset for centering
            const offsetX = padding + (canvas.width - padding * 2 - (maxX - minX) * scale) / 2;
            const offsetY = padding + (canvas.height - padding * 2 - (maxY - minY) * scale) / 2;
            
            // Check if mouse is over any node
            let hoveredNode = null;
            
            for (const [nodeId, node] of graph.nodes.entries()) {
                const degree = graph.getDegree(nodeId);
                const radius = Math.max(5, Math.min(15, 5 + degree * 2));
                
                const x = offsetX + (node.x - minX) * scale;
                const y = offsetY + (node.y - minY) * scale;
                
                const distance = Math.sqrt(
                    Math.pow(mouseX - x, 2) + 
                    Math.pow(mouseY - y, 2)
                );
                
                if (distance <= radius) {
                    hoveredNode = { ...node, id: nodeId };
                    break;
                }
            }
            
            if (hoveredNode) {
                // Show tooltip with node info
                tooltip.style.display = 'block';
                tooltip.style.left = `${event.clientX + 10}px`;
                tooltip.style.top = `${event.clientY + 10}px`;
                
                const neighbors = graph.getNeighbors(hoveredNode.id);
                
                tooltip.innerHTML = `
                    <strong>Node ID:</strong> ${hoveredNode.id}<br>
                    <strong>Coordinates:</strong> (${hoveredNode.x.toFixed(2)}, ${hoveredNode.y.toFixed(2)}, ${hoveredNode.z.toFixed(2)})<br>
                    <strong>Connections:</strong> ${neighbors.length}<br>
                    <strong>Connected to:</strong> ${neighbors.join(', ') || 'None'}
                `;
                
                canvas.style.cursor = 'pointer';
            } else {
                // Hide tooltip if not hovering over a node
                tooltip.style.display = 'none';
                canvas.style.cursor = 'default';
            }
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html> 